---
title: Rvalue Reference
description: 
published: true
date: 2024-07-29T13:37:49.025Z
tags: 
editor: markdown
dateCreated: 2024-07-29T13:37:49.025Z
---

# Rvalue Reference

## `lvalue`

> An `lvalue` which placed to the left of the equal sign has a name and can be addressed.

### *Example for* `lvalue`

- Function name and variable name.
- Return lvalued referenced function call.
- Prefix increment/decrement expression (*++i, --i*).
- Expression concatenated by an assignment expression or an assignment operator (*a=b, a+=b, etc.*).
- Dereference expression *p.
- String literal "abcd".

## `rvalue`

> An `rvalue` is the exact opposite of an `lvalue`.

```c++
int a = b + c; // a is lvalue, b + c is rvalue
int a = 4; // a is lvalue, 4 is rvalue
```

## `Pure rvalue`

> It's an `rvalue`

### *Example for* `Pure rvalue`

- Temporary variables generated by operation expressions.
- Original literals not associated with objects.
- Temporary variables returned by non-references.
- Postincrement and decrement expressions (*i++, i--*).
- Lambda expressions.
- Etc.

## `Dying value`

> It is a new expression associated with an rvalue reference in C++11.</br>

- It's an `rvalue`. This can be understood as the value to be destroyed. A value obtained by "stealing" the memory space of another variable
- Usually refers to the object to be moved.
- The return value of the `T&&` function.
- The return value of `std::move` function.
- The return value converted to a `T&&` type conversion function.

### *PS*

To ensure that other variables are no longer used or are about to be destroyed, you can avoid freeing and allocating memory space, extend the life cycle of variable values, and often accomplish the special task of moving constructs or moving assignments.

## `lvalue/rvalue reference`

```c++
type &name = exp; // lvalue reference
type &&name = exp; // rvalue reference
```

## `std::move`

### *Deep/Shallow Copy*

> Opening up a new memory storage resource/Simple assignment of data.

### *Header for* `std::move`

```c++
#include <utility>
```

### *Effect for* `std::move`

Forces an `lvalue` to an `rvalue` reference that can then be used by an `rvalue` reference to move semantics. `std::move` is basically the same as a type conversion:

```c++
static_cast<T&&>(lvalue);
```

### *Notice for* `std::move`

- In a library container such as `std::vector`, unnecessary copying operations can be avoided by `std::move`.

- `std::move` transfers the state or ownership from one object to another. Just move, no memory move or memory copy so it can improve utilization efficiency and performance.

- This is not necessary for library objects of pointer type.

- Move semantics apply only to objects whose classes implement the move constructor.

## `Perfect Forwarding`

> A function template that takes any argument, and passes it to some other function, the target function will receive exactly the same argument as the forward function, the forward function argument is an lvalue and the target function argument is an lvalue and the forward function argument is an rvalue and the target function argument is an rvalue

### *Using `std::forward`*

```c++
void printV(int& t) {
    std::cout << "lvalue" << std::endl;
}

void printV(int&& t) {
    std::cout << "rvalue" << std::endl;
}

template<typename T>
void test(T&& t) {
    printV(t);
    printV(std::forward<T>(t));
    printV(std::move(t));
}

int main() {
    test(1); // lvalue rvalue rvalue
    int a = 1;
    test(a); // lvalue lvalue rvalue
    test(std::forward<int>(a)); // lvalue rvalue rvalue
    test(std::forward<int&>(a)); // lvalue lvalue rvalue
    test(std::forward<int&&>(a)); // lvalue rvalue rvalue
    return 0;
}
```

## `Return Value Optimization` (*RVO*)

### *Why*

> When a function needs to return an instance of an object, a temporary object is created and the target object is copied to the temporary object by the copy constructor. There copy constructors and destructors that are called unnecessarily, at a cost, and the C++ standard allows these copy constructors to be omitted through return value optimization.

### *When*

- The value type of return is the same as the return value type of the function.
- Return is a local object

### *How*

```c++
std::vector<int> ReturnVector(void)
{
    std::vector<int> tmp {1,2,3,4,5};
    return tmp;
}

std::vector<int> rval_ref = ReturnVector();
```
